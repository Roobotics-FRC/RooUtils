""" Calculates velocity, acceleration, and jerk of a robot based on encoder outputs generated by EncoderOutputCommand.
Automatically sorts time values (enabling use of higher-performance HashMaps) and smooths data.
Wheel diameter and gearbox ratio must be specified in order to ensure correct conversion to inches.
Note that the demo position data CSV was obtained using a robot with 15-inch wheels.
"""

import math
from matplotlib import pyplot
from scipy.signal import butter, filtfilt

WHEEL_DIAMETER = 6  # in inches
GEARBOX_RATIO = 1 / 8.71  # should be 1:n, not n:1

pos_pts = []

with open('position-data.csv') as pos_data:
    for line in pos_data:
        row_elements = line.replace('\n', '').split(',')
        # time units are given in milliseconds - convert to seconds
        time = int(row_elements[0]) / 1000

        # convert "units" to in based on 15-in wheel diameter and 4096 units/revolution
        # (the 1.5 is to compensate for unknown error)
        pos = int(row_elements[1]) * WHEEL_DIAMETER * math.pi / 4096
        pos_pts.append([time, pos])

# we need to sort the data points because the CSV data came from a hash map, which isn't ordered
pos_pts.sort(key=lambda l: l[0])

# make all times and positions relative to start to make the numbers nicer
start_time = pos_pts[0][0]
start_pos = pos_pts[0][1]

# also, since the encoder was recording out of phase, negate all of the positions
pos_pts = [[pt[0] - start_time, -(pt[1] - start_pos)] for pt in pos_pts]


# utility smoothing functions (src: https://stackoverflow.com/questions/28536191/how-to-filter-smooth-with-scipy-numpy)
def butter_lowpass(cutoff, fs, order=5):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    return b, a


def butter_lowpass_filtfilt(data, cutoff, fs, order=5):
    b, a = butter_lowpass(cutoff, fs, order=order)
    y = filtfilt(b, a, data)
    return y


def smooth_points(pts):
    vals = [pt[1] for pt in pts]
    vals = butter_lowpass_filtfilt(vals, 1500, 50000)
    return [[pts[i][0], vals[i]] for i in range(0, len(pts))]


# calculates rate of change on each pair of points in a point list to generate a list (length n-1) of derivative points
# times in derivative points will be averages of the points between which rate of change was generated
# for instance, (x, m) and (y, n) yield derivative point ((x+y)/2, (n-m)/(y-x))
# finally, the output is smoothed
def generate_derivative(pts):
    derivative_pts = []

    for i in range(1, len(pts)):
        cur_val = pts[i][1]
        prev_val = pts[i - 1][1]
        cur_time = pts[i][0]
        prev_time = pts[i - 1][0]

        derivative_at_pt = (cur_val - prev_val) / (cur_time - prev_time)
        avg_time = (cur_time + prev_time) / 2

        derivative_pts.append([avg_time, derivative_at_pt])

    derivative_pts = smooth_points(derivative_pts)
    return derivative_pts


# separates a point array into a time array and a vals array for plotting
def plottable(pt_array):
    times = []
    vals = []
    for pt in pt_array:
        times.append(pt[0])
        vals.append(pt[1])
    return times, vals


# smooth positions
pos_pts = smooth_points(pos_pts)

# generate derivatives
vel_pts = generate_derivative(pos_pts)
acc_pts = generate_derivative(vel_pts)
jerk_pts = generate_derivative(acc_pts)

# plot derivatives
pos_times, pos_vals = plottable(pos_pts)
vel_times, vel_vals = plottable(vel_pts)
acc_times, acc_vals = plottable(acc_pts)
jerk_times, jerk_vals = plottable(jerk_pts)

pyplot.plot(pos_times, pos_vals)
pyplot.plot(vel_times, vel_vals)
pyplot.plot(acc_times, acc_vals)
pyplot.plot(jerk_times, jerk_vals)
pyplot.show()

# find max values and print them
vel_vals = map(lambda e: abs(e), vel_vals)
acc_val = map(lambda e: abs(e), acc_vals)
jerk_vals = map(lambda e: abs(e), jerk_vals)

max_vel = max(vel_vals)
max_acc = max(acc_vals)
max_jerk = max(jerk_vals)

print(f'Maximum velocity: {max_vel} in/sec\t'
      f'Maximum acceleration: {max_acc} in/sec^2\t'
      f'Maximum jerk: {max_jerk} in/sec^3')
